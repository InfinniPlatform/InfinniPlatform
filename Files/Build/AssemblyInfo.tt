<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Security.Cryptography" #>
<#@ import namespace="System.Text" #>
<#@ output extension=".cs" #>
<#
	var projectName = GetProjectName();
	var currentProjectHash = GetProjectHash();

	int major;
	int minor;
	int build;
	int revision;
	string projectGuid;
	string projectHash;

	try
	{
		using(var stream = OpenResultFile())
		{
			int.TryParse(ReadHeaderLine(stream), out major);
			int.TryParse(ReadHeaderLine(stream), out minor);
			int.TryParse(ReadHeaderLine(stream), out build);
			int.TryParse(ReadHeaderLine(stream), out revision);
			projectGuid = ReadHeaderLine(stream);
			projectHash = ReadHeaderLine(stream);

			if (!string.Equals(projectHash, currentProjectHash, StringComparison.OrdinalIgnoreCase))
			{
				projectHash = currentProjectHash;
				revision += 1;
			}
		}
	}
	catch
	{
		major = 1;
		minor = 0;
		build = 0;
		revision = 0;
		projectGuid = Guid.NewGuid().ToString("D");
		projectHash = currentProjectHash;
	}
#>
// <#= major #>
// <#= minor #>
// <#= build #>
// <#= revision #>
// <#= projectGuid #>
// <#= projectHash #>
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("<#= projectName #>")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Infinnity Solutions")]
[assembly: AssemblyProduct("InfinniPlatform")]
[assembly: AssemblyCopyright("Copyright © Infinnity Solutions <#= DateTime.Today.Year #>")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: ComVisible(false)]
[assembly: Guid("<#= projectGuid #>")]
[assembly: AssemblyVersion("<#= major #>.<#= minor #>.<#= build #>.<#= revision #>")]
[assembly: AssemblyFileVersion("<#= major #>.<#= minor #>.<#= build #>.<#= revision #>")]
<#
	if (!projectName.EndsWith(".Tests"))
	{
#>[assembly: InternalsVisibleTo("<#= projectName #>.Tests")]<#
	}
#>
<#+
	string GetProjectName()
	{
		return Path.GetFileName(GetProjectDirectory()) ?? "";
	}

	string GetProjectHash()
	{
		var directoryHash = new DirectoryHash(MD5.Create, excludeFiles: DefaultExcludeFiles);
		return directoryHash.ComputeHash(GetProjectDirectory()) ?? "";
	}

	string GetProjectDirectory()
	{
		return Path.GetDirectoryName(Path.GetDirectoryName(Host.TemplateFile));
	}

	StreamReader OpenResultFile()
	{
		return File.OpenText(Host.ResolvePath("AssemblyInfo.cs"));
	}

	string ReadHeaderLine(StreamReader stream)
	{
		while (!stream.EndOfStream)
		{
			var line = stream.ReadLine();

			if (!string.IsNullOrWhiteSpace(line) && line.Length > 3)
			{
				return line.Substring(3);
			}
		}

		return null;
	}

	static readonly string[] DefaultExcludeFiles =
	{
		@"\Package.nuspec",
		@"\AssemblyInfo.cs",
		@"\.hg\", @"\.git\",
		@"\bin\", @"\obj\", @"\debug\", @"\logs\", @"\assemblies\",
		".suo", ".orig", ".csproj.user", ".csproj.DotSettings", "_ReSharper"
	};

	class DirectoryHash
	{
		private const int HashBufferSize = 1024 * 1024;
		private readonly Func<HashAlgorithm> _hashFactory;
		private readonly string[] _includeFiles;
		private readonly string[] _excludeFiles;
		private readonly byte[] _hashBuffer;

		public DirectoryHash(Func<HashAlgorithm> hashFactory, string[] includeFiles = null, string[] excludeFiles = null)
		{
			_hashFactory = hashFactory;
			_includeFiles = includeFiles;
			_excludeFiles = excludeFiles;
			_hashBuffer = new byte[HashBufferSize];
		}

		public string ComputeHash(string directoryPath)
		{
			if (string.IsNullOrEmpty(directoryPath))
			{
				throw new ArgumentNullException("directoryPath");
			}

			IEnumerable<string> files = Directory.GetFiles(directoryPath, "*", SearchOption.AllDirectories);

			if (_includeFiles != null)
			{
				files = files.Where(f => _includeFiles.Any(p => f.IndexOf(p, StringComparison.OrdinalIgnoreCase) >= 0));
			}

			if (_excludeFiles != null)
			{
				files = files.Where(f => _excludeFiles.All(p => f.IndexOf(p, StringComparison.OrdinalIgnoreCase) < 0));
			}

			var hashFiles = files.OrderBy(i => i).ToArray();

			if (hashFiles.Length > 0)
			{
				var hash = _hashFactory();

				var dirLength = directoryPath.Length;
				var header = string.Join(Environment.NewLine, hashFiles.Select(f => f.Substring(dirLength + 1)));

				HashNextBlock(hash, header);

				foreach (var hashFile in hashFiles)
				{
					using (var hashStream = File.OpenRead(hashFile))
					{
						HashNextBlock(hash, hashStream);
					}
				}

				return HashFinalBlock(hash);
			}

			return null;
		}

		private void HashNextBlock(HashAlgorithm hash, Stream data)
		{
			int count;
			var buffer = _hashBuffer;

			while ((count = data.Read(buffer, 0, buffer.Length)) > 0)
			{
				HashNextBlock(hash, buffer, count);
			}
		}

		private static void HashNextBlock(HashAlgorithm hash, string data)
		{
			var buffer = Encoding.UTF8.GetBytes(data);
			HashNextBlock(hash, buffer, buffer.Length);
		}

		private static void HashNextBlock(HashAlgorithm hash, byte[] data, int count)
		{
			hash.TransformBlock(data, 0, count, data, 0);
		}

		private static string HashFinalBlock(HashAlgorithm hash)
		{
			hash.TransformFinalBlock(new byte[0], 0, 0);
			return BitConverter.ToString(hash.Hash).Replace("-", "");
		}
	}
#>